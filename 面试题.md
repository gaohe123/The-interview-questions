# vue

## 生命周期

created：初始化了$el(dom节点)，data和methods（请求放在哪？因为这个时候初始化data和methods，所以在这近早的发起请求）

## 组件通信

父子：父组件绑定一个属性，通过子组件的props接收

子父：在父组件的子组件上定义一个事件，通过this.$emit来派发

兄弟：建一个空的envbus(事件总线),导出vue实例，在组件内引入用$emit派发，用$on来接收，vuex

多级：通过provide传递，通过inject接收

## 通过下标更改数组

使用方法如splice，pop，push，unshift

原理：vue内部重写了这些数组的操作方法，所以被调用时会感知到

## 有时候设置某些属性没有变化

使用$set动态添加

原理：用$set动态添加的属性会使用object.difineproperty()去劫持对象

## vue的双向绑定原理

通过object.difineproperty（）劫持对象，在get函数中收集依赖，在set函数中通知更新。

## key的作用

标识vnode（虚拟节点）的唯一性可以在diff算法中进行新旧节点的虚拟dom树对比，没有变化的不替换，

## index作为key的不好的地方

index是有变化的，不具有唯一性，所以在diff算法中进行新旧节点的虚拟dom树对比时，虽然dom节点没变化，但是key值不一样，所以会导致重新渲染

## 常用的指令

v-html:用innerHTML

v-text：用innerTEXT

v-if：通过添加删除节点进行显示隐藏

v-show：通过display进行显示隐藏，频繁显示隐藏时用，

v-for：优先大于v-if，不建议和v-if一起使用，与key搭配使用

v-bind：绑定属性

v-on：绑定事件

v-once：只渲染一次

v-model:

## 常用的修饰符

.stop:阻止事件冒泡

.prevent:阻止默认事件

.trim:去除前后空格

.once:只触发一次

.keydown:建盘摁下

.number:将数据转换为数字

.sync:可以让子组件双向绑定

.native:绑定dom的原生事件

## 绑定事件不生效

使用.native

原理：绑定dom的原生事件

## keep-alive

名称：缓存组件

用法：

生命周期：activated激活时   deactivated未激活时

属性：

max:缓存的最大数量

include：可以缓存的组件名称

exclude：不可以缓存的组件名称

## data为什么是个函数

防止组件在重复使用时，数据互相干扰，使用函数将产生新作用域，所以同一个组件在不同位置被使用时，不适用同一份数据

## computed,watch,methods的区别

computed 计算结果会缓存，如果依赖值发生改变，就会重新调整计算结果，有get和set函数。

watch: 监听数据变化，可以接收新值和旧值，

   属性 

​      deep：开启深度监听 

​	  immediate：立即执行没有旧值

​      handler：执行函数

``` js
watch: {
    name(new,old) {
    },
    name: {
        deep:true,
        immediate:true,
        hanlder: function(new,old) {
                
        }
    }
}
```

methods 事件方法 执行一次，调用一次，不会缓存

## 怎么操作dom元素

ref

document.querySelector

document.getElementById

document.getElementsByName/ByClassName/ByTagName

# 路由

## 传值方式

query：通过url传参，刷新值不会变化，不能传输对象。获取方式： this.$route.query.id

params：可以传递对象，但是刷新会消失。获取方式：this.$route.params.id

## $route和$router的区别

$route：路由对象，包含当前的路由信息。

$router：包含路由的操作方法。

## 路由模式

hash：就是在url中加#，因为加#，url地址变化不会刷新页面。

history：没有#，url地址看起来更友好，但是会刷新页面。

## 如果用history模式会有什么问题？

页面显示不出来，因为404了，所以如果要用history模式就得配置404跳转到首页。

## 守卫

### 全局路由守卫

beforeEach：接收三个参数：from,to,next(回调函数，执行则进行下一个页面。)

afterEach

## 组件内路由守卫

beforeRouteEnter

beforeRouteLeave

beforeRouteUpdate

## 路由独享守卫

beforeEach

## 跳转方式

push：跳转

go：返回多少级，-1,-2,-3

replace：将当前路径删除，跳转路径加入

# vuex

## 使用场景

存储全局变量时。

## 使用时遇到的问题

页面刷新后就丢失了

## 页面刷新时数据会否丢失

会，使用持久化插件，将数据存储到localStorage或sessionStorage中。

## 五大核心

state： 存放状态 所有的数据都存储在state中 state是一个对象

mutations： 可以直接操作state中的数据

getters： 类似计算属性实现对state中的数据做一些逻辑性的操作

actions： 异步操作 一般在这里面调用mutations的方法进行更改数据

modules： 将仓库分模块存储

# JS

## var,let,const区别

var 存在变量提升，可以重复定义，在全局中定义的数据会挂载到window上。

let const在{}中定义的变量属于块级作用域，不可重复定义，在定义前使用会存在暂时性死区的问题。

const 定义的是常量，如果定义的是常量则不可修改，因为无法修改它的引用地址。

## 闭包

访问函数内部变量的函数就是闭包。

优点：

1. 避免污染全局环境。
2. 延迟计算
3. 定义私有变量

缺点：

	1. 容易造成内存泄露  解决办法：把它的引用设置为null

## 原型和原型链

原型：每个对象都有一个特殊的属性叫作`原型（prototype）`，在原型上定义的属性和方法会被每一个实例对象共享。

原型链：获取对象属性时，如果对象本身没有这个属性，那就会去他的原型`__proto__`上去找，如果还查不到，就去找原型的原型，一直找到最顶层(`Object.prototype`)为止。Object.prototype对象也有__proto__属性值为null

## es6新特性

ES6新增特性常⽤的主要有：let/const,箭头函数，模板字符串，解构赋值，扩展操作符，模块的导⼊(import)和导出(export default/export),Promise,还有⼀些数组字符串的扩展⽅法,其实有很多，我平时常⽤的就这些

## es6数组常用的方法

filter()：创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素（注意：它不会对空数组检测，它不会改变原数组）

1、Array.from( )：将对象或字符串转成数组，注意得有length。

2、Array.of( )： 将一组值转换为数组。

3、copyWithin(target，start(可选)，end(可选))：数组内数据的复制替换

target：从该位置开始替换数据；

start：从该位置开始读取数据，默认为0；

end：到该位置停止数据的读取，默认为数组的长度

4、find( )：用于找出第一个符合条件的数组成员。

5、findIndex( )：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。

6、fill(value，start，end)：使用给定值，填充一个数组。

value：填充的值；

start：开始填充的位置；

end：填充结束的位置。

7、keys( )：对键名的遍历。

8、values( )：对键值的遍历。

9、entries( )：对键值对的遍历。

10、includes( )：数组原型的方法,查找一个数值是否在数组中，只能判断一些简单类型的数据，对于复杂类型的数据无法判断。该方法接受两个参数，分别是查询的数据和初始的查询索引值。

11、flat( )：用于数组扁平，数组去除未定义。

12、flatMap( )：对原数组的每个成员执行一个函数。
 ， 
13、Map( )：是一组键值对的结构，具有极快的查找速度。

14、Set( )：Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。

## 箭头函数的this指向

主要是用来改变this的指向，就是说如果创建一个构造函数，我们在里面再加一个函数，它们两个的this指向不同，第一个指向实例的本身，而第二个默认指向window

因为箭头函数有一个特性，就是不绑定this，会捕获其定义时所在的this指向作为自己的this

## this指向

默认绑定规则：直接调用函数符合默认绑定规则，this指向window。

隐式绑定规则：对象点函数，this指向调用它的这个对象，就是谁点的它绑定谁。

显式绑定规则：使用call,apply,bind调用的方法，this指向call,apply,bind绑定的对象。

new绑定规则：new一个对象会使用new绑定规则，this指向对象的实例。

## Promise

解决了什么问题：回调地狱的问题。

promise有三种状态：

分别是Pending(进行中)、fulfiled（成功）、Rejectd（失败）。如果成功就执行成功的回调函数，失败就执行失败的。

属于微任务。

状态从pending变更到成功和失败之后就不能再变更了。

## js事件循环机制

js是单线程，所以有三个任务队列，同步任务，微任务，宏任务，每次先执行同步任务，在执行微任务，在执行宏任务，全部完成后再从头开始，这样周而复始的循环叫做事件循环

## JS继承

盗用构造函数：通过call，apply将要继承的函数的this指向当前的this。缺点：无法继承原型链上的属性和方法。

原型链继承：直接new一个对象赋值给prototype，缺点就是所有的属性都会被共享。

组合继承：结合盗用构造函数和原型链继承两种方式，既继承了原型链上的方法，又将构造函数中的属性添加到了实例对象上。

## 跨域解决方式

Jsonp：利用script标签的src属性不受同源策略的限制，可以利用src去调用后端的接口。缺点：必须定义一个全局方法。

反向代理：就是利用一个中间服务将我们发起的请求转发到服务端，并且在返回的时候在响应头里添加允许跨域的头。vue中的配置方法：在vue.config.js中配置proxy代理。

cors：后端在响应头里添加允许跨域的头，这个是后端解决的。

## 什么是跨域

协议域名端口一致是同源策略，如果违反了同源策略，则会造成跨域。

# http

## http和https的区别

HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

## 有哪些请求

get：把参数放在url中，所以传输的数据是透明的，有大小限制。

post：把请求数据放在body中，传输数据大，请求比get慢，因为会先发送一个options预请求去询问服务器能否接受这个请求。

put：更新。

delete：对这个资源的删操作。但要注意：客户端无法保证删除操作一定会被执行，因为http规范允许服务器在不通知客户端的情况下撤销请求。

patch：有一个对象你要更新有十个属性，但只能更新两个属性，只能部分。

options：用于获取当前URL所支持的方法。若请求成功，则会在http头中包含一个名为"Allow"的头，值是所支持的方法，如get和post

## 三次握手

第一次握手：客户端发送网络包，服务端收到了。这时候服务端的都结论：客户端的发送能力、服务端的接受能力正常。

第二次握手：服务端收到网络包会给客户端响应，这时候服务端发送网络包，客户端收到了，此时的服务端得出结论：服务端的发送能力没有问题，因为客户端没有给服务端响应。

第三次握手：客户端收到网络包后，给服务端响应，这时候客户端给服务端发送网络包，服务端收到了，此时服务端得出结论：客户端的发送、接受能力没有问题，自己的发送，接受能力也没有问题。

# 项目相关

## 登录鉴权的实现方式

## 动态路由的实现方式

后端会根据当前登录人的角色返回相应的权限菜单，我们会在全局路守卫中进行判断，如果当前进入的路径在这个权限菜单中，则可以跳转，如果不在的话我们就跳转到首页中。

## 移动端怎么做的适配

使用postcss-px-to-viewport这个插件将px转换为vw。

## vw是什么？

视口宽的百分比。

## rem是什么？

**是指相对于根元素的字体大小的单位**

按照设计稿的宽去设置一个合适的rem ,配合js查询屏幕大小来改变html的font-size，从而达到适配各种屏幕的效果

## 用rem做适配了解过吗？

没有，我们通常用vw做适配

## 用过Echarts中的哪些图表？

柱形图，线型图，饼图

## 对axios做过哪些二次封装？

首先设置它的busURL，它的基地址，然后去封装它的请求拦截器和响应拦截器，在请求拦截器里边咱们一般会给它的header加上验证头会把token传入，在响应拦截器里边我们会对这个将要返回的数据进一步处理，然后我们还会去判断它的http  响应码，一般会在里边判断401，如果是401的话就相当于身份未校验或token失效，我们会把本地的token清空，然后跳转的登录页去，让它重新登录

## token值会过期吗？怎么处理？

会，token有失效时间，在请求的响应拦截器中去判断状态码是否为401，如果是401 token失效，清空token，弹出警告框告知用户跳转到登录页面重新登录

## 封装过哪些组件？

封装组件大多封装业务组件，这个功能组件比较少。

## 封装组件的思路？有哪些考虑？

业务组件我们要首先考虑他的组件通用性，组件用在那些地方，那些变化，那些不变化，变化的东西放到props中。

## 项目优化

代码层面的话尽量减少冗余代码，命名要规范，提高代码的可读性。然后使用组件懒加载、路由懒加载等技术让非及时显示的页面或组件闲时下载。

打包方面的话将小图配置打包成base64，更小的icon图标打包成精灵图，开启Treeshaking，按需导入用到的方法，减少不必要的代码体积。然后开启多线程打包，加快打包速度。

部署方面的话可以使用CDN加快访问速度。

其实核心就是首页一定要小，这样才能尽快渲染出来，请求文件一定要少，不要让css或js等文件的请求影响了渲染速度。

## 进新公司的工作流程

先把开发工具（vscode、git、乌龟git、nodejs）装好（如果之前电脑没装好的话），先问领导`git`用https还是ssh链接方式，如果是https的话就等领导给你开好账号，然后使用账号密码把代码 git clone 把代码克隆下来就行，如果是ssh的话就执行 ssh-keygen -t rsa 命令生成公私秘钥，并且将公钥给领导，领导将你的公钥添加完成后就可以使用 git clone 命令直接克隆代码了。